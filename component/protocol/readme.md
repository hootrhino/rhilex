### 协议指南文档

#### 1. 概述
![1735542530017](image/readme/1735542530017.png)


本协议用于串口通信的数据包传输，数据包格式包括包头、数据体、包尾以及校验机制。协议遵循以下结构：

```
| Header (2 bytes) | Length (1 byte) | Data (variable) | Checksum (1 byte) | Tail (2 bytes) |
```

- **Header (2 bytes)**: 固定的包头标识符，默认是 `0xAF 0x00`。
- **Length (1 byte)**: 数据体的长度，指定数据部分的字节数。
- **Data (variable)**: 数据内容，长度由 `Length` 字段指定。
- **Checksum (1 byte)**: 校验和字段，用于验证数据的完整性。
- **Tail (2 bytes)**: 固定的包尾标识符，默认是 `0xFA 0x00`。

#### 2. 数据包格式

- **包头 (Header)**：数据包的起始标志，使用固定的 2 字节表示。
- **长度 (Length)**：1 字节，指定随后的数据体部分的长度（即 Data 部分的字节数）。
- **数据体 (Data)**：长度为 `Length` 字段指定的可变长度部分。
- **校验和 (Checksum)**：1 字节，用于简单的校验计算，校验和是数据体部分所有字节的异或值。
- **包尾 (Tail)**：数据包的结束标志，使用固定的 2 字节表示。

#### 3. 校验和计算

校验和计算方式是：对数据体部分（不包括头部和尾部）进行按位异或操作，得到的结果就是校验和。

例如：

- **数据体**：`0x01 0x02 0x03`
- **校验和**：`0x01 ^ 0x02 ^ 0x03 = 0x00`

#### 4. 示例

假设我们有如下的数据包：
```
| Header    | Length | Data           | Checksum | Tail      |
| --------- | ------ | -------------- | -------- | --------- |
| 0xAF 0x00 | 0x03   | 0x01 0x02 0x03 | 0x00     | 0xFA 0x00 |
```

- **Header**: `0xAF 0x00`
- **Length**: `0x03` (表示数据体长度为 3 字节)
- **Data**: `0x01 0x02 0x03`
- **Checksum**: `0x00` (计算方式是 `0x01 ^ 0x02 ^ 0x03`)
- **Tail**: `0xFA 0x00`

#### 5. 错误处理

- **包头错误**：如果包头不匹配（即不是 `0xAF 0x00`），则丢弃该包。
- **包尾错误**：如果包尾不匹配（即不是 `0xFA 0x00`），则丢弃该包。
- **长度错误**：如果数据体的实际长度与 `Length` 字段不符，则丢弃该包。
- **校验错误**：如果计算出的校验和与包中的校验和不匹配，则丢弃该包。

### Arduino 示例

假设我们希望使用 Arduino 发送符合上述协议的数据包。下面是一个示例代码，它使用 Arduino 的串口来发送数据包。

```cpp
#define HEADER1 0xAF
#define HEADER2 0x00
#define TAIL1   0xFA
#define TAIL2   0x00

void setup() {
  Serial.begin(9600);  // 设置串口通信波特率为9600
}

void loop() {
  // 示例数据体
  byte data[] = {0x01, 0x02, 0x03};

  // 计算校验和
  byte checksum = 0;
  for (int i = 0; i < sizeof(data); i++) {
    checksum ^= data[i];
  }

  // 构造数据包
  byte packet[5 + sizeof(data)] = {
    HEADER1, HEADER2,  // 包头
    sizeof(data),      // 数据长度
  };

  // 将数据体复制到包中
  for (int i = 0; i < sizeof(data); i++) {
    packet[3 + i] = data[i];
  }

  // 校验和
  packet[3 + sizeof(data)] = checksum;

  // 包尾
  packet[4 + sizeof(data)] = TAIL1;
  packet[5 + sizeof(data)] = TAIL2;

  // 发送数据包
  Serial.write(packet, sizeof(packet));

  // 暂停一段时间，模拟数据包发送的间隔
  delay(1000);
}
```

#### 代码说明：

1. **串口初始化**：使用 `Serial.begin(9600)` 初始化串口通信，设置波特率为 9600。
2. **数据包构造**：
   - 头部（`0xAF 0x00`）和尾部（`0xFA 0x00`）是固定的。
   - 使用 `sizeof(data)` 来表示数据体的长度。
   - 计算数据体部分的校验和。
   - 构造完整的数据包，并使用 `Serial.write()` 发送出去。
3. **数据发送**：每发送一次数据包后，延迟 1 秒，再发送下一个包。

### 如何对接？

1. **串口设置**：确保 Arduino 和接收设备（例如，`Transport` 类实例）使用相同的串口参数（波特率、数据位、停止位等）。
2. **协议一致性**：确保发送的数据包格式遵循本协议（包括包头、包尾、数据长度和校验和等）。
3. **数据处理**：接收设备（例如，使用 `GenericByteParser`）应当正确解析收到的字节流。如果接收到符合协议的数据包，则进行进一步的处理；如果数据包不符合协议，则丢弃该包或报告错误。

### 使用流程

1. **Arduino 端**：
   - 编写并上传 Arduino 程序到设备。
   - 程序会通过串口持续发送符合协议的数据包。
2. **接收端（如 Raspberry Pi 或 PC）**：
   - 启动接收程序，使用串口读取数据。
   - 使用 `GenericByteParser` 解析接收到的数据包，校验包头、包尾、数据长度及校验和。
   - 对有效数据进行处理（如存储、显示等）。

---

### 总结

以上协议设计提供了一种简单、可靠的串口通信协议，旨在确保数据传输的边界清晰并提供错误检测机制。通过确保包头和包尾标志、数据长度和校验和的验证，可以保证数据传输的完整性和正确性。Arduino 示例提供了一个简单的实现方式，便于与接收端进行对接。